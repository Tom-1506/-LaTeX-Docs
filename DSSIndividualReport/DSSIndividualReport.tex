\documentclass{ueacmpstyle}

\RequirePackage{natbib}
\usepackage{graphicx,caption}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{appendix}
\usepackage[hyphens]{url}

\begin{document}
	\title{Developing Secure Systems Individual Report}
	\author{
		100203952 -- Thomas Mcloughlin\\
		CMP-6045B
	}
	\maketitle

    \section{Introduction}\label{sec:Intro}
    This report will present research of the top cyber threats and vulnerabilities of modern 
    systems with the aim of identifying methods to mitigate them.

    \section{Part 1}\label{sec:Pt1}
        % \cite{bibItem} << Example cite command (Look at overleaf tutorials) 
        % \ref{app:A} << This example references appendix A (Look at overleaf tutorials) 
        
        \subsection{Account Enumeration}\label{sub:AccEnum}
        Account enumeration is the manipulation of a service's login function to determine 
        the existence of a user. Attackers would determine this through two actions, first 
        by inputting a username and password into the login and if a message is received 
        stating that the password is wrong but not the username, then the attacker now 
        knows that the username exists. The way to mitigate this manipulation is to return 
        a generic message for a login failure not specifying whether the username or 
        password is wrong, however this mitigation can be nullified using the second method 
        where the attacker will try to log in and then compare the time taken to resolve the 
        failed login. If the response was quick then the username doesn't exist, if the 
        reponse took slightly longer then the service recognised the username and took longer 
        to try and match the password. This manipulation can also be mitigated by applying a 
        delay to the reponse when the username is wrong so that the attacker could not 
        tell the difference between the two responses.
        The mitigation methods described above fit into a secure by design approach because 
        they are concerned with the back end implementation details of the system and are 
        obscured well from any attackers. These techniques have been represented as 
        pseudocode in section \ref{sec:account-enumeration} of Appendix A.

        Threat actors likely to use account enumeration are attackers of any kind that could 
        range from casual programmers to criminal hackers trying to access various services. 
        A likely attack vector for using attack enumeration would be if the attacker had 
        gained access to a list of passwords for a service and was trying to find users to 
        match to so that they could break into the system.

        The interaction between the end users and the service will not be greatly affected 
        by the implementation of these mitigations with respect to the improved security 
        they provide, these mitigations do not affect the process of a sucessful login. 
        The only problem that can arise with usability will be that if a user forgets their 
        password or isn't sure what username they used for the service, the generic message 
        not specifying which is wrong can be frustrating and make logging in more difficult. 

        \subsection{Session Hijacking}\label{sub:SessHijk}
        Session hijacking is the utilisation of a lack of security given to website sessions 
        where a user that has logged in creates a session with the web server so that they 
        can make requests to the server without having to send log in details for every 
        request. These sessions have an attached ID so that the web server knows which user 
        it is communicating with, session hijacking refers to the multiple methods used to 
        gain access to a session, usually by accessing the ID. 

        When attempting to gain access using the ID, one possibility could be that the site 
        uses existent session ID's rather than generating a new ID for every session. This 
        opens up the session for attack from session fixation where the attacker uses a 
        known ID in a phishing email link to have the user login and authenticate themselves 
        then the attacker can hijack the session using the session ID \citep{OWASPSessionFixation}.

        There are multiple methods used to acquire session ID's to use for session fixation. 
        Session sniffing, the use of packet sniffing software to intercept session packets 
        and acquire the session ID attached to it, this can be done manually by the attacker 
        or the attacker may use malware to automate the process. The attacker may also brute 
        force the ID's by going through all possible permutations of the ID.

        The threat actors likely to use session hijackers are the same as stated above 
        in \ref{sub:AccEnum}. The risk posed by these attacks are: the attackers would 
        be able to gain access to a user authenticated login and perform any actions that the 
        user would be able to within that session such as a money transfer, the attacker would 
        also have access to any personal information that the session allows the user to view 
        which may lead to ID theft, the attacker may encrypt valuable/vital data for ransom 
        which could include intellectual property.

        The main methods to mitigate session hijacking attacks include: making session ID's 
        long and complex to avoid brute force access, make the site use a new session for 
        each time a user logs in and give each new session a unique ID to stop access if a 
        previously used ID has been compromised, ensure that a session is closed once a user 
        logs out or if the session is not being used and times out and finally, all session 
        data should be encrypted to prevent sniffing and malware attacks from accessing the 
        session ID's. Another method of mitigation extraneous to any technical measures 
        would include the training of end users to spot and avoid phishing emails.

        Generating a unique ID with enough complexity to avoid ID guessing is very important. 
        Therefore an example ID generation algorithm has been included as an acceptable 
        method shown in section \ref{sec:session-id-gen}. This algorithm was created using 
        recommended practices from \cite{OWASPSessionManagement} such as ensuring the entropy 
        number used is 64 bits to give an acceptable level of complexity.

        The addition of any of the mentioned mitigations would have very little affect on 
        the end users as the mitigations proposed are mainly secure by design techniques 
        that are more concerned with backend interaction. Usability will not be sacrificed 
        to a noticeable degree, the only affect on the user would be the requirement to 
        always log back into the system once they leave as the session they previously used 
        would have been closed.

        \subsection{SQL Injection}\label{sub:SqlInject}

        
    \section{Part 2}\label{sec:Pt2}

    \section{Conclusion}\label{sec:Con}
    
    \bibliographystyle{apalike}

	\bibliography{bibfile.bib}
	
	\newpage
	
	\appendix
	    % Using appendices in this format means you can just use \section{}
        \section{Appendix A}\label{app:A}   % Adding the label will allow you to reference this section in your work.
            \newpage

            \begin{figure}[ht]
                \subsection{Account Enumeration Mitigation}
                \label{sec:account-enumeration}
                \centering
                \begin{algorithm}[H]
                \caption{login(\emph{username}, \emph{password}) {\bf return} \emph{response}}
                      \begin{algorithmic}[1]
                          \Require $username$, the username for login
                          \Require $password$, the password for login
                          \Require $users$, the set of users and passwords that the system will 
                                    compare the login against
                          \Ensure \emph{response}, either a sucessful login or a response message
                          \State{$Failure \leftarrow$ "The username/password is incorrect"}
                          \ForAll{$user$ in $users$}
                            \If{$username$ = $user.username$}
                              \If{$password$ = $user.password$}
                                \State{$response \leftarrow Sucess$}
                                \Comment{Username and password correct}
                              \Else
                                \State{$response \leftarrow Failure$}  
                                \Comment{Username correct, password incorrect}
                              \EndIf
                            \Else
                            \State{$delay$} 
                            \Comment{Wait however long the check for the password would take}
                            \State{$response \leftarrow Failure$}
                            \Comment{Username and password incorrect}  
                            \EndIf
                          \EndFor
                          \State \Return $response$
                      \end{algorithmic}
                \end{algorithm}
                \caption{Example of a login with account enumeration mitigation included}
                \label{fig:account-enumeration}
            \end{figure}

            \begin{figure}[ht]
              \subsection{Session ID Generation}
              \label{sec:session-id-gen}
              \centering
              \begin{algorithm}[H]
              \caption{generateUniqueSessionId() {\bf return} \emph{sessionId}}
                    \begin{algorithmic}[1]
                        \Require $IdList$, the set of existing session Id's
                        \Require $prng$, pseudo random number generator
                        \Ensure \emph{sessionId}, a unique session Id
                        \State $entropy \leftarrow prng(64)$
                        \Comment{Pseudo random number generation of length 64 bits}
                        \State $Id \leftarrow generateId()$
                        \Comment{Generate complex Id}
                        \State $sessionId \leftarrow concatenate(Id, entropy)$
                        \If{$sessionId \in IdList$}
                          \State generateUniqueSessionId()
                          \Comment{Session Id isn't unique, generate a new Id}
                        \EndIf
                        \State \Return $sessionId$
                    \end{algorithmic}
              \end{algorithm}
              \caption{Example of a random session Id generator using recommended practices 
                       from \cite{OWASPSessionManagement}}
              \label{fig:session-id-gen}
          \end{figure}

        \section{Appendix B}\label{app:B}

\end{document}
